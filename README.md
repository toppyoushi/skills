
# 今天在尝试下方虚函数表地址访问代码时遇到的问题：
===
```
    #include <iostream>
    using namespace std;
    class Base
    {
    public:
        virtual void f()
        {
            cout << "Base::f()" << endl;
        }
        virtual void g()
        {
            cout << "Base::g()" << endl;
        }
        virtual void h()
        {
            cout << "Base::h()" << endl;
        }
    };
    class Derive : public Base
    {
    public:
        virtual void f1()
        {
            cout << "Derive::f1()" << endl;
        }
        virtual void g1()
        {
            cout << "Derive::g1()" << endl;
        }
        virtual void h1()
        {
            cout << "Derive::h1()" << endl;
        }
    };
    int main()
    {
        typedef void (*Fun)();
        Base *b;
        Derive d;
        b = &d;
        Fun bf = (Fun)*((size_t *)*(size_t *)b);
        Fun bg1 = (Fun)*((size_t *)*(size_t *)b+1);
        Fun bg2 = (Fun)*((int *)*(int *)b + 2);
        Fun bh1 = (Fun)*((size_t *)*(size_t *)b + 2);
        Fun bh2 = (Fun)*((int *)*(int *)b + 4);
        bf();
        bg1();
        bg2();
        bh1();
        bh2();
        return 0;
    }

```

===
1. typedef void （*Fun)()函数指针语法不会，查阅博客得知这是定义返回类型为void，形式参数为空的函数指针Fun
2. 对指针b的类型转换，``` Fun b1fun = (Fun)(*(size_t *)*(size_t *)b); ```该语句从右向左，首先将指针b转化为size_t型得到虚函数表中第一个虚函数的地址，再进行一次相同的转换得到该虚函数的函数指针，指针的加减操作是和其所指类型相关的，+1操作得到的是下一个函数指针的地址，网上的博客使用的是int而不是size_t，主要是32位系统与64位系统间的差别，在我自己电脑上如果使用int需要+2，说明64位系统中指针大小为8字节而32位系统为4字节
注意：虚函数表位于c++内存模型的只读数据段，虚函数位于代码段，验证方法见这个博客:https://blog.csdn.net/qq_28114615/article/details/98041319
3. 父类的指针即使指向子类实例是无法访问任何非重载父类成员函数的自有成员函数的，会被编译器报错，但是通过对虚函数表的访问，可以做到

===
引用：数据类型 & 引用名 = 被引用变量
为变量建立引用相当于给它取别名，且必须初始化，与某一变量绑定，引用不是独立数据类型，也不会为其创建内存空间，而是与被绑定的变量存入同一内存？
在程序中声明了b是a的引用，实际上在内存中开辟了一个指针型的储存单元，在其中放变量a的地址，输出引用b时，就输出b所指向的变量a的值，相当于*b.引用其实就是一个指针变量，它的指针不能改变，只能指向一个指定的变量。所以引用的本质还是指针。
这两句话来自同一篇博客，WTF   明白了，引用不会为其指向的变量分配空间，但不代表引用本身不占空间，引用本身占一个指针的内存空间
不能声明引用数组，可以声明数组引用
引用作为函数返回值：当函数的返回值不是一个变量的引用时，一定会创建一个临时变量，返回变量的引用，避免在内存中产生返回值的副本
引用做返回值应遵守的规则：
- 不能返回局部变量的引用，因为函数体结束变量就被销毁了
- 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
- 可以返回类成员的引用，但最好是const

常引用：左侧加const，常引用只能get不能set
引用与指针的异同：
1. 相同点：底层的实现都是指针
2. 不同点：
    - 引用必须初始化，指针可以只声明
    - 引用一旦与某一变量绑定，就不能再与另一变量建立引用
    - 引用不能为NULL，指针可以为NULL
    - 对引用sizeof，得到的是其所引用的变量类型的字节大小，而对指针sizeof得到的是固定值32位为4字节，64位为8字节
    - 引用自加后是对被引用值自加，而指针自加是指向某个该指针类型的空间
    - 没有多级引用，有多级指针
    - 指针手动寻址，引用编译器寻址

===
# C++ 重载
1. 函数重载
## 定义
    函数重载指在同一作用域，一组含有不同形参列表的同名函数，没有返回值不同这一条件，主要是为了在解析时不依赖于上下文
```
float sqrt(float);
double sqrt(double);

void f(double da, float fla)
{
      float fl=sqrt(da);//调用sqrt(double)
      double d=sqrt(da);//调用sqrt(double)

      fl=sqrt(fla);//调用sqrt(float)
   d=sqrt(fla);//调用sqrt(float)
}
```
    同一作用域主要体现在类的函数重载

## 为什么要用函数重载
- 许多功能相似而仅仅是参数不同的函数，需要不断取不同名字会非常不友好
- 类的构造函数与类名完全相同，如果不进行构造函数的重载，不能做到多种方法实例化对象
- 运算符重载实际上就是一种函数重载

## 编译器的解析
    编译器将重载函数解析为命名空间+返回值+函数名+形参

## 重载函数调用时如何正确地匹配
判断规则:
- 精准匹配：不对参数类型转换或只做很细微的转换，如数组名转指针，函数名转函数指针，非const转const
- 提升匹配：整数提升，bool到int，char到int，short到int，float到double
- 使用标准转换匹配： 如int到double，double到int，Derived\*到Base\*，T \*到void \*,int到unsigned int
- 省略号匹配
