# Linux及操作系统相关

## Linux 五种I/O模型

1. 阻塞I/O: 用户进程进行系统调用后进入阻塞状态，不占用CPU，系统进程在数据还没有准备完成时也不返回，直到系统进程返回数据
2. 非阻塞I/O: 用户进程进行系统调用后不被阻塞，系统进程若数据没有准备好，立即返回读取失败，之后用户进程还会多次调用，直到  
系统进程数据准备好，此时再进入阻塞读取数据
3. I/O复用: 用户进程调用select后会进入阻塞状态，而系统进程能够接收多个select请求，并在各个socket中轮询，当某个socket
所需数据准备好了，则会通知用户进程，此时用户进程解除阻塞，开始读取数据，而又进入阻塞
4. 信号驱动I/O: 用户进程调用信号驱动I/O后不阻塞继续运行，内核将数据准备好后向用户进程发送信号，用户进程接收到信号后，再
进入阻塞读数据
5. 异步I/O: 用户进程发送读数据请求后内核直接返回，用户进程继续运行，当内核数据准备完成后自动将数据复制到用户内存区，并发送
信号，用户并不是主动阻塞去读数据
`上述5中模型，前4种都是同步的，只有第五种才是异步的`

## 集中多路复用解决方案的比较

1. select()

    - select()使用数组方式管理fd，单进程能够监听的fd数量有限
    - select()每次都会将所有待监听的fd复制到内核态，在fd数量较多时会占用大量系统资源
    - select()采用轮询的方式，从头到尾询问，不会考虑套接字活跃程度

2. poll()

    - 与select()类似，区别在于使用链表方式管理fd，单进程能够监听的fd数量没有限制

3. epoll()

    - epoll()没有最大监听数量的限制
    - 并不是采用轮询的方式，而是考虑每个套接字的活跃程度
    - 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销

## 进程相关

ECF为应用程序提供到操作系统的入口
应用进程是通过系统调用向操作系统请求服务

## 进程通信5种方式

1. 管道
    - 匿名管道：在内核中申请一块固定大小的缓冲区，程序拥有读写的权利，只能用于父子进程间的通信
    - 命名管道：在内核中申请一块固定大小的缓冲区，程序拥有读写的权利，没有血缘关系的进程间也可以相互通信
特点：面向字节流，半双工，两个管道可以实现双向通信，自带同步互斥机制

2. 消息队列

3. 信号量

4. 共享内存区

## 源程序到可执行文件的过程：预编译、编译、汇编、链接

1. 预编译：处理头文件的内容，查找相应的头文件并把它插入到源程序中，生成后缀名.i的文件

2. 编译和汇编，将源程序翻译成汇编语言，进而翻译成机器语言，生成.o文件

3. 链接：将多个.o文件链接成可执行文件，链接可发生在编译时，装入内存时，甚至是运行时 

## 存储器层次架构

由快到慢：寄存器（CPU）、高速缓存cache（L1,L2，L3）、主存（内存）、二级存储（磁盘）、远程二级存储（分布式文件系统、Web服务器）

## 进程、进程调度、进程通信、锁、线程

操作系统通过进程抽象内存、I/O和存储设备的关系，通过上下文切换完成并发执行程序的要求，
上下文切换通过进程向操作系统发起系统调用，转入操作系统内核，内核常驻在内存中，是管理进程全部数据结构及代码的集合
进程中通过线程完成并行，线程共享全局变量和代码

进程是资源分配的基本单位，线程是CPU调度的基本单位，创建进程就是创建进程控制块PCB，进程拥有资源而线程只能访问其隶属进程的资源
创建和撤销进程时，操作系统都要为其分配和收回资源，如I/O设备，内存空间，进程进行上下文切换还要保存CPU状态，而进程切换只需要
保存和设置少量寄存器，线程间的通信可以直接读写同一进程的数据，而进程间通信大多要系统调用，开销较大
进程三个状态：就绪、运行、阻塞
位于就绪队列的进程被CPU通过调度算法调度后进入运行状态，分给它的时间片轮完后回到就绪队列，等待I/O操作时进入阻塞状态，I/O完成后进入就绪状态
父进程创建子进程，子进程得到父进程用户进虚拟地址空间相同的副本，还获得父进程打开的文件描述符的副本，即子进程可以读写父进程打开的文件
### 进程调度算法

分几种情况：

1. 批处理系统：
1.1 先来先服务（FCFS）非抢占式，对长任务