# Linux 五种I/O模型

1. 阻塞I/O: 用户进程进行系统调用后进入阻塞状态，不占用CPU，系统进程在数据还没有准备完成时也不返回，直到系统进程返回数据
2. 非阻塞I/O: 用户进程进行系统调用后不被阻塞，系统进程若数据没有准备好，立即返回读取失败，之后用户进程还会多次调用，直到  
系统进程数据准备好，此时再进入阻塞读取数据
3. I/O复用: 用户进程调用select后会进入阻塞状态，而系统进程能够接收多个select请求，并在各个socket中轮询，当某个socket
所需数据准备好了，则会通知用户进程，此时用户进程解除阻塞，开始读取数据，而又进入阻塞
4. 信号驱动I/O: 用户进程调用信号驱动I/O后不阻塞继续运行，内核将数据准备好后向用户进程发送信号，用户进程接收到信号后，再
进入阻塞读数据
5. 异步I/O: 用户进程发送读数据请求后内核直接返回，用户进程继续运行，当内核数据准备完成后自动将数据复制到用户内存区，并发送
信号，用户并不是主动阻塞去读数据
`上述5中模型，前4种都是同步的，只有第五种才是异步的`

## 集中多路复用解决方案的比较

1. select()

    - select()使用数组方式管理fd，单进程能够监听的fd数量有限
    - select()每次都会将所有待监听的fd复制到内核态，在fd数量较多时会占用大量系统资源
    - select()采用轮询的方式，从头到尾询问，不会考虑套接字活跃程度

2. poll()

    - 与select()类似，区别在于使用链表方式管理fd，单进程能够监听的fd数量没有限制

3. epoll()

    - epoll()没有最大监听数量的限制
    - 并不是采用轮询的方式，而是考虑每个套接字的活跃程度
    - 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销

# 进程相关

ECF为应用程序提供到操作系统的入口
应用进程是通过系统调用向操作系统请求服务

## 进程通信5种方式

1. 管道
    - 匿名管道：在内核中申请一块固定大小的缓冲区，程序拥有读写的权利，只能用于父子进程间的通信
    - 命名管道：在内核中申请一块固定大小的缓冲区，程序拥有读写的权利，没有血缘关系的进程间也可以相互通信
特点：面向字节流，半双工，两个管道可以实现双向通信，自带同步互斥机制

2. 消息队列

# 进程、进程调度、进程通信、锁、线程
